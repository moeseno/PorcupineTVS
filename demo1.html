<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PorcupineTVS Visualizer</title>
    <style>
        body { margin: 0; overflow: hidden; background: #0a0a0a; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; color: white; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        .panel {
            position: absolute;
            background: rgba(20, 20, 20, 0.85);
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
            backdrop-filter: blur(10px);
            pointer-events: none; /* Let clicks pass through to the 3D scene by default */
        }
        
        .interactive-ui {
            pointer-events: auto; /* Re-enable clicks for toggles */
        }

        #title-panel { top: 20px; left: 20px; width: 340px; }
        #title-panel h1 { margin: 0 0 10px 0; font-size: 18px; color: #ffffff; }
        #title-panel p { margin: 0; font-size: 12px; color: #aaa; line-height: 1.4; }

        .settings-box {
            margin-top: 15px;
            background: rgba(0, 0, 0, 0.4);
            padding: 12px;
            border-radius: 6px;
            border: 1px solid #444;
            font-size: 13px;
        }
        .settings-box label {
            cursor: pointer;
            display: flex;
            align-items: center;
            margin-bottom: 6px;
            color: #eee;
            transition: color 0.2s;
        }
        .settings-box label:hover { color: #fff; }
        .settings-box input { margin: 0 8px 0 0; cursor: pointer; }
        .section-title {
            margin-bottom: 8px;
            color: #aaa;
            font-weight: bold;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        #live-panel { bottom: 20px; left: 20px; width: 340px; }
        #live-panel .keys { font-size: 24px; font-weight: bold; color: #ffffff; letter-spacing: 2px; height: 35px; text-shadow: 0 0 10px rgba(255,255,255,0.5); }
        
        #target-panel { top: 20px; right: 20px; width: 300px; border-color: #ffff00; display: none; }
        #target-panel h2 { margin: 0 0 5px 0; font-size: 16px; color: #ffff00; }
        #target-panel .instruction { font-size: 14px; font-weight: bold; color: white; margin-bottom: 10px; background: #333; padding: 10px; border-radius: 4px; line-height: 1.6; }

        .key-badge {
            display: inline-block; padding: 2px 8px; margin: 2px;
            background: #222; border: 1px solid #555; border-radius: 4px; font-family: monospace;
        }
        
        .legend-key { font-weight: bold; padding: 2px 6px; border-radius: 3px; background: #222; text-shadow: 0 0 4px rgba(0,0,0,0.8);}
    </style>
    <!-- Import Three.js -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
</head>
<body style="forced-color-adjust:none">

    <!-- UI Overlay -->
    <div id="title-panel" class="panel">
        <h1 id="title-heading">Porcupine Temporal Vector Steering</h1>
        <p>A movement logic mapping <b id="dir-count">98</b> unique directions.<br>Spike colors are a visual mix of the keys used to create them.</p>
        
        <!-- Interactive Settings Panel -->
        <div class="settings-box interactive-ui">
            <div class="section-title">Input System</div>
            <label><input type="radio" name="system" value="temporal" checked> Temporal (Order-based)</label>
            <label style="margin-bottom:12px;"><input type="radio" name="system" value="traditional"> Traditional (Canceling)</label>
            
            <div class="section-title">Dimension Mode</div>
            <label><input type="radio" name="dimension" value="3d" checked> 3D (WASD + QE)</label>
            <label style="margin-bottom:0;"><input type="radio" name="dimension" value="2d"> 2D (WASD only)</label>
        </div>

        <div style="margin-top: 15px; font-size: 13px;">
            <b style="color: #aaa;">Key Legend:</b><br>
            <div style="margin-top: 5px; display: grid; grid-template-columns: 1fr 1fr; gap: 6px;">
                <div><span class="legend-key" style="color:#0088ff">W</span> Forward</div>
                <div><span class="legend-key" style="color:#ffaa00">S</span> Backward</div>
                <div><span class="legend-key" style="color:#00ffcc">A</span> Left</div>
                <div><span class="legend-key" style="color:#ff0055">D</span> Right</div>
                <div><span class="legend-key" style="color:#b200ff">Q</span> Down</div>
                <div><span class="legend-key" style="color:#aaff00">E</span> Up</div>
            </div>
        </div>
        <p style="margin-top: 15px; color:#888;"><i>Drag to rotate camera. Click a thorn to see its key sequence.</i></p>
    </div>

    <div id="live-panel" class="panel">
        <div style="font-size:12px; color:#aaa; margin-bottom:5px;">Currently Pressing:</div>
        <div id="active-keys" class="keys">NONE</div>
        <div style="font-size:12px; color:#aaa; margin-top:5px;">Live Vector: <span id="active-vector" style="color:#fff">(0.00, 0.00, 0.00)</span></div>
    </div>

    <div id="target-panel" class="panel">
        <h2>Target Direction</h2>
        <div class="instruction" id="target-instruction">Hold A, then press W + D</div>
        <div style="font-size:11px; color:#888;" id="target-vector-text">Vector: </div>
    </div>

    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        class PorcupineDemo {
            constructor() {
                this.initScene();
                this.initLogic();
                this.generateThorns();
                this.setupInputs();
                this.setupToggles();
                this.animate();
            }

            initScene() {
                this.container = document.getElementById('canvas-container');
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.FogExp2(0x0a0a0a, 0.015);

                this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(25, 20, 35);

                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.container.appendChild(this.renderer.domElement);

                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.autoRotate = false;

                const ambient = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambient);
                const dir = new THREE.DirectionalLight(0xffffff, 1.2);
                dir.position.set(10, 20, 10);
                this.scene.add(dir);

                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();

                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }

            initLogic() {
                this.TAN_22_5 = 0.41421356237;
                this.keys = { w:false, a:false, s:false, d:false, q:false, e:false };
                this.timestamps = {};
                
                this.isTemporal = true;
                this.is3D = true;
                
                this.keyColors = {
                    'W': new THREE.Color('#0088ff'),
                    'S': new THREE.Color('#ffaa00'),
                    'A': new THREE.Color('#00ffcc'),
                    'D': new THREE.Color('#ff0055'),
                    'E': new THREE.Color('#aaff00'),
                    'Q': new THREE.Color('#b200ff') 
                };

                this.matActive = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 0.8, roughness: 0.2 }); 
                this.matClicked = new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xaa8800, emissiveIntensity: 0.6, roughness: 0.2 });

                this.thorns =[];
                this.activeThorn = null;
                this.clickedThorn = null;
            }

            setupToggles() {
                const sysRadios = document.querySelectorAll('input[name="system"]');
                const dimRadios = document.querySelectorAll('input[name="dimension"]');

                sysRadios.forEach(r => r.addEventListener('change', (e) => {
                    this.isTemporal = (e.target.value === 'temporal');
                    this.updateVisibility();
                    this.updateLiveState();
                }));

                dimRadios.forEach(r => r.addEventListener('change', (e) => {
                    this.is3D = (e.target.value === '3d');
                    this.updateVisibility();
                    this.updateLiveState();
                }));
                
                // Set initial counts properly
                this.updateVisibility();
            }

            updateVisibility() {
                let visibleCount = 0;

                this.thorns.forEach(t => {
                    const vec = t.userData.logicalVec;
                    let isVisible = true;
                    
                    // Filter 1: Traditional Mode hides fractional vectors
                    if (!this.isTemporal) {
                        if (Math.abs(vec.x) === this.TAN_22_5 || 
                            Math.abs(vec.y) === this.TAN_22_5 || 
                            Math.abs(vec.z) === this.TAN_22_5) {
                            isVisible = false;
                        }
                    }
                    
                    // Filter 2: 2D Mode hides Q/E (Y-axis) vectors
                    if (!this.is3D) {
                        if (vec.y !== 0) {
                            isVisible = false;
                        }
                    }
                    
                    t.visible = isVisible;
                    if (isVisible) visibleCount++;
                });

                document.getElementById('dir-count').textContent = visibleCount;
                document.getElementById('title-heading').textContent = 
                    this.isTemporal ? "Temporal Vector Steering" : "Traditional Input Logic";

                // Clear selections if the currently selected items are now hidden
                if (this.activeThorn && !this.activeThorn.visible) {
                    this.setActiveThorn(null);
                }
                if (this.clickedThorn && !this.clickedThorn.visible) {
                    this.setClickedThorn(null);
                }
            }

            getColorForVector(x, y, z) {
                const mixedColor = new THREE.Color(0x000000);
                let totalWeight = 0;

                const addWeight = (key, weight) => {
                    const c = this.keyColors[key];
                    mixedColor.r += c.r * weight;
                    mixedColor.g += c.g * weight;
                    mixedColor.b += c.b * weight;
                    totalWeight += weight;
                };

                const processAxis = (val, posKey, negKey) => {
                    if (val === 1) addWeight(posKey, 1.0);
                    if (val === -1) addWeight(negKey, 1.0);
                    if (val === this.TAN_22_5) { 
                        addWeight(posKey, 1.0);  
                        addWeight(negKey, 0.35); 
                    }
                    if (val === -this.TAN_22_5) { 
                        addWeight(negKey, 1.0); 
                        addWeight(posKey, 0.35); 
                    }
                };

                processAxis(x, 'D', 'A'); 
                processAxis(y, 'E', 'Q'); 
                processAxis(z, 'S', 'W'); 

                if (totalWeight > 0) {
                    mixedColor.r /= totalWeight;
                    mixedColor.g /= totalWeight;
                    mixedColor.b /= totalWeight;
                }

                return mixedColor;
            }

            generateThorns() {
                const values =[-1, -this.TAN_22_5, 0, this.TAN_22_5, 1];
                const radius = 10;
                
                const geoCyl = new THREE.CylinderGeometry(0.08, 0.2, radius, 8);
                geoCyl.translate(0, radius / 2, 0); 
                const geoSphere = new THREE.SphereGeometry(0.5, 16, 16);

                const centerGeo = new THREE.SphereGeometry(1.2, 32, 32);
                const centerMesh = new THREE.Mesh(centerGeo, new THREE.MeshStandardMaterial({color: 0x111111}));
                this.scene.add(centerMesh);

                values.forEach(x => {
                    values.forEach(y => {
                        values.forEach(z => {
                            // Filter redundant fractional directions/dead-zones
                            if (Math.max(Math.abs(x), Math.abs(y), Math.abs(z)) < 1.0) return;

                            const dir = new THREE.Vector3(x, y, z).normalize();

                            const spikeColor = this.getColorForVector(x, y, z);
                            const spikeMat = new THREE.MeshStandardMaterial({ 
                                color: spikeColor, 
                                metalness: 0.3, 
                                roughness: 0.4
                            });

                            const group = new THREE.Group();
                            
                            const cyl = new THREE.Mesh(geoCyl, spikeMat);
                            cyl.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir);
                            
                            const tip = new THREE.Mesh(geoSphere, spikeMat);
                            tip.position.copy(dir).multiplyScalar(radius);
                            
                            group.add(cyl);
                            group.add(tip);
                            
                            group.userData = {
                                logicalVec: new THREE.Vector3(x, y, z),
                                dir: dir,
                                meshes: [cyl, tip],
                                baseMaterial: spikeMat,
                                instruction: this.generateInstructionString(x, y, z)
                            };

                            this.scene.add(group);
                            this.thorns.push(group);
                        });
                    });
                });
            }

            getColoredKeyBadge(keyStr) {
                const hex = this.keyColors[keyStr].getHexString();
                return `<span class="key-badge" style="color: #${hex}; border-color: #${hex}44;">${keyStr}</span>`;
            }

            generateInstructionString(x, y, z) {
                const older =[];
                const newer =[];

                const decode = (val, posKey, negKey) => {
                    if (val === 1) newer.push(this.getColoredKeyBadge(posKey));
                    if (val === -1) newer.push(this.getColoredKeyBadge(negKey));
                    if (val === this.TAN_22_5) { 
                        older.push(this.getColoredKeyBadge(posKey)); 
                        newer.push(this.getColoredKeyBadge(negKey)); 
                    }
                    if (val === -this.TAN_22_5) { 
                        older.push(this.getColoredKeyBadge(negKey)); 
                        newer.push(this.getColoredKeyBadge(posKey)); 
                    }
                };

                decode(x, 'D', 'A');
                decode(y, 'E', 'Q');
                decode(z, 'S', 'W');

                let str = "";
                if (older.length > 0) {
                    str += `Hold ${older.join(' + ')}<br>then press ${newer.join(' + ')}`;
                } else {
                    str += `Press ${newer.join(' + ')}`;
                }
                return str;
            }

            setupInputs() {
                window.addEventListener('keydown', e => {
                    const k = e.key.toLowerCase();
                    if (this.keys.hasOwnProperty(k) && !this.keys[k]) {
                        this.keys[k] = true;
                        this.timestamps[k] = window.performance.now();
                        this.updateLiveState();
                    }
                });

                window.addEventListener('keyup', e => {
                    const k = e.key.toLowerCase();
                    if (this.keys.hasOwnProperty(k)) {
                        this.keys[k] = false;
                        this.updateLiveState();
                    }
                });

                window.addEventListener('pointerdown', e => {
                    // Prevent raycasting if clicking on interactive UI layers (toggles)
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'LABEL') return;

                    this.mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                    this.mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                    
                    this.raycaster.setFromCamera(this.mouse, this.camera);
                    
                    // Ensure we only raycast objects that are currently visible
                    const visibleThorns = this.thorns.filter(t => t.visible);
                    const meshes = visibleThorns.map(t => t.userData.meshes).flat();
                    const intersects = this.raycaster.intersectObjects(meshes);

                    if (intersects.length > 0) {
                        let hitGroup = intersects[0].object;
                        while(hitGroup.parent && !hitGroup.userData.instruction) {
                            hitGroup = hitGroup.parent;
                        }
                        this.setClickedThorn(hitGroup);
                    } else {
                        this.setClickedThorn(null);
                    }
                });
            }

            getLiveAxisValue(posKey, negKey) {
                const pos = this.keys[posKey];
                const neg = this.keys[negKey];
                
                if (pos && neg) {
                    // If Traditional is active, oppose/conflicting keys cancel out to 0
                    if (!this.isTemporal) {
                        return 0.0; 
                    }
                    if (this.timestamps[posKey] < this.timestamps[negKey]) return this.TAN_22_5;
                    else return -this.TAN_22_5;
                } else if (pos) return 1.0;
                else if (neg) return -1.0;
                
                return 0.0;
            }

            updateLiveState() {
                let activeArr = Object.keys(this.keys)
                    .filter(k => this.keys[k])
                    .sort((a, b) => this.timestamps[a] - this.timestamps[b]);
                
                // If in 2D mode, filter out Q & E from the live input sequence display entirely
                if (!this.is3D) {
                    activeArr = activeArr.filter(k => k !== 'q' && k !== 'e');
                }
                
                if (activeArr.length > 0) {
                    const styledKeys = activeArr.map(k => {
                        const hex = this.keyColors[k.toUpperCase()].getHexString();
                        return `<span style="color:#${hex}">${k.toUpperCase()}</span>`;
                    });
                    document.getElementById('active-keys').innerHTML = styledKeys.join(' <span style="color:#555">â†’</span> ');
                } else {
                    document.getElementById('active-keys').textContent = 'NONE';
                }

                const x = this.getLiveAxisValue('d', 'a');
                const z = this.getLiveAxisValue('s', 'w');
                // Calculate Y only if 3D mode is permitted
                const y = this.is3D ? this.getLiveAxisValue('e', 'q') : 0.0;

                if (Math.max(Math.abs(x), Math.abs(y), Math.abs(z)) < 1.0) {
                    this.setActiveThorn(null);
                    document.getElementById('active-vector').textContent = `(0.00, 0.00, 0.00)`;
                    return;
                }

                const dir = new THREE.Vector3(x, y, z).normalize();
                document.getElementById('active-vector').textContent = `(${dir.x.toFixed(2)}, ${dir.y.toFixed(2)}, ${dir.z.toFixed(2)})`;

                let bestMatch = null;
                let highestDot = -1;
                
                // Only consider thorns that are actually visible for visual activation
                this.thorns.filter(t => t.visible).forEach(t => {
                    const dot = t.userData.dir.dot(dir);
                    if (dot > highestDot) {
                        highestDot = dot;
                        bestMatch = t;
                    }
                });

                if (highestDot > 0.99) {
                    this.setActiveThorn(bestMatch);
                } else {
                    this.setActiveThorn(null);
                }
            }

            updateMaterials() {
                this.thorns.forEach(t => {
                    let mat = t.userData.baseMaterial;
                    if (t === this.clickedThorn) mat = this.matClicked;
                    if (t === this.activeThorn) mat = this.matActive; 
                    t.userData.meshes.forEach(m => m.material = mat);
                });
            }

            setActiveThorn(thorn) {
                if (this.activeThorn !== thorn) {
                    this.activeThorn = thorn;
                    this.updateMaterials();
                }
            }

            setClickedThorn(thorn) {
                this.clickedThorn = thorn;
                const panel = document.getElementById('target-panel');
                
                if (thorn) {
                    panel.style.display = 'block';
                    document.getElementById('target-instruction').innerHTML = thorn.userData.instruction;
                    const v = thorn.userData.dir;
                    document.getElementById('target-vector-text').textContent = 
                        `Normalized Vector: (${v.x.toFixed(2)}, ${v.y.toFixed(2)}, ${v.z.toFixed(2)})`;
                } else {
                    panel.style.display = 'none';
                }
                this.updateMaterials();
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                this.controls.update();
                this.renderer.render(this.scene, this.camera);
            }
        }

        window.onload = () => new PorcupineDemo();
    </script>
</body>
</html>