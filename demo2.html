<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PorcupineTVS Movement Lab</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000000; font-family: 'Segoe UI', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; }
        
        #hud {
            position: absolute;
            color: #ffffff;
            top: 20px;
            left: 20px;
            background: #000000;
            padding: 15px;
            border: 3px solid #ffffff;
            width: 180px;
            pointer-events: none;
            z-index: 100;
        }

        .compass {
            position: relative;
            width: 80px;
            height: 80px;
            margin: 10px auto;
            border: 2px solid #ffffff;
            border-radius: 50%;
            background: #000000;
        }

        #needle {
            position: absolute;
            width: 4px;
            height: 40px;
            background: #ff0000;
            left: 38px;
            bottom: 50%;
            transform-origin: bottom center;
            display: none;
        }

        #blocker {
            position: absolute;
            width: 100%; height: 100%;
            background: #000000;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            z-index: 1000; cursor: pointer;
        }

        .kb-hint { font-family: monospace; font-size: 12px; color: #ffffff; margin-top: 10px; }
    </style>
</head>
<body style="forced-color-adjust:none">

    <div id="blocker">
        <h1 style="margin:0; letter-spacing: -1px; color:#ffffff">PorcupineTVS Movement Lab</h1>
        <p style="background: #000000; color: #ffffff; padding: 10px 20px; margin-top: 20px; font-weight: bold;">CLICK TO START</p>
        <p class="kb-hint">WASD = 16 DIRECTIONS | MOUSE = ORBIT | SPACE = JUMP</p>
    </div>

    <div id="hud">
        <div style="font-size: 10px; text-align: center; font-weight: bold;">INPUT VECTOR</div>
        <div class="compass"><div id="needle"></div></div>
        <div id="dir-name" style="text-align: center; font-weight: bold; font-size: 20px;">IDLE</div>
    </div>

    <div id="canvas-container"></div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';

        class StableDemo {
            constructor() {
                this.TAN_22_5 = 0.41421356;
                this.initScene();
                this.initLevel();
                this.initPlayer();
                this.initInput();
                this.animate();
            }

            initScene() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0xf0f0f0);
                this.scene.fog = new THREE.Fog(0xf0f0f0, 20, 150);

                this.camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.setPixelRatio(window.devicePixelRatio);
                document.getElementById('canvas-container').appendChild(this.renderer.domElement);

                this.scene.add(new THREE.AmbientLight(0xffffff, 0.8));
                const sun = new THREE.DirectionalLight(0xffffff, 1.2);
                sun.position.set(50, 100, 50);
                sun.castShadow = true;
                this.scene.add(sun);

                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }

            initLevel() {
                this.colliders = [];
                const floor = new THREE.Mesh(
                    new THREE.PlaneGeometry(500, 500),
                    new THREE.MeshStandardMaterial({ color: 0xeeeeee })
                );
                floor.rotation.x = -Math.PI / 2;
                floor.receiveShadow = true;
                this.scene.add(floor);
                this.colliders.push(floor);

                const grid = new THREE.GridHelper(500, 100, 0x000000, 0xcccccc);
                grid.position.y = 0.01;
                this.scene.add(grid);

                for(let i=0; i<16; i++) {
                    const angle = i * 22.5 * (Math.PI / 180);
                    const length = 40;
                    const x = Math.sin(angle) * (length/2 + 6);
                    const z = -Math.cos(angle) * (length/2 + 6);
                    
                    const isEven = i % 2 === 0;
                    const beamHeight = isEven ? 1.5 : 1.0; 
                    const yPos = isEven ? 0.5 : 0.8; 

                    const beam = new THREE.Mesh(
                        new THREE.BoxGeometry(4.0, beamHeight, length),
                        new THREE.MeshStandardMaterial({ 
                            color: isEven ? 0xff3366 : 0x3399ff,
                            roughness: 0.6
                        })
                    );
                    
                    beam.position.set(x, yPos + 0.05, z); 
                    beam.rotation.y = angle;
                    beam.castShadow = true;
                    beam.receiveShadow = true;
                    this.scene.add(beam);
                    this.colliders.push(beam);
                }
            }

            initPlayer() {
                this.player = new THREE.Group();
                const char = new THREE.Mesh(
                    new THREE.CapsuleGeometry(0.5, 1, 4, 8),
                    new THREE.MeshStandardMaterial({ color: 0x222222 })
                );
                char.position.y = 1;
                this.player.add(char);
                
                const arrow = new THREE.Mesh(
                    new THREE.ConeGeometry(0.3, 0.8, 4),
                    new THREE.MeshStandardMaterial({ color: 0x00ff00 })
                );
                arrow.rotation.x = Math.PI / 2;
                arrow.position.set(0, 0.1, -1.2);
                this.player.add(arrow);
                this.scene.add(this.player);

                this.cameraRig = new THREE.Object3D();
                this.scene.add(this.cameraRig);
                this.cameraPitch = new THREE.Object3D();
                this.cameraRig.add(this.cameraPitch);
                this.cameraPitch.add(this.camera);
                this.camera.position.set(0, 4, 10); 
                this.camera.lookAt(0, 1.5, 0);

                this.velocity = new THREE.Vector3();
                this.isGrounded = false;
                this.moveSpeed = 16;
                this.jumpForce = 13;
                this.gravity = 35;
                this.camYaw = 0;
                this.camPitch = -0.3;
            }

            initInput() {
                this.keys = { w: false, a: false, s: false, d: false, space: false };
                this.times = { w: 0, a: 0, s: 0, d: 0 };
                this.isLocked = false;

                const blocker = document.getElementById('blocker');
                blocker.addEventListener('click', () => blocker.requestPointerLock());

                document.addEventListener('pointerlockchange', () => {
                    this.isLocked = document.pointerLockElement === blocker;
                    blocker.style.display = this.isLocked ? 'none' : 'flex';
                });

                window.addEventListener('keydown', e => {
                    const k = e.key.toLowerCase();
                    if(k === ' ') this.keys.space = true;
                    if(this.keys[k] === false) {
                        this.keys[k] = true;
                        this.times[k] = performance.now();
                    }
                });
                window.addEventListener('keyup', e => {
                    const k = e.key.toLowerCase();
                    if(k === ' ') this.keys.space = false;
                    if(this.keys[k] === true) this.keys[k] = false;
                });

                document.addEventListener('mousemove', e => {
                    if (this.isLocked) {
                        this.camYaw -= e.movementX * 0.003;
                        this.camPitch -= e.movementY * 0.003;
                        this.camPitch = Math.max(-0.8, Math.min(0.2, this.camPitch));
                    }
                });
            }

            getTemporalVector() {
                // If all 4 keys are held, return a total stop
                if (this.keys.w && this.keys.s && this.keys.a && this.keys.d) {
                    return new THREE.Vector3(0, 0, 0);
                }

                // Determine if a primary axis is active
                const vertActive = (this.keys.w && !this.keys.s) || (this.keys.s && !this.keys.w);
                const horActive = (this.keys.d && !this.keys.a) || (this.keys.a && !this.keys.d);

                const getAxisVal = (posKey, negKey, otherAxisIsActive) => {
                    const p = this.keys[posKey];
                    const n = this.keys[negKey];

                    if (p && n) {
                        // If opposing keys are held, they only result in a vector (Trim)
                        // IF the other axis is currently providing a primary direction.
                        // Otherwise, they cancel to zero.
                        if (otherAxisIsActive) {
                            return this.times[posKey] < this.times[negKey] ? this.TAN_22_5 : -this.TAN_22_5;
                        }
                        return 0;
                    }
                    return p ? 1 : (n ? -1 : 0);
                };

                const x = getAxisVal('d', 'a', vertActive);
                const z = getAxisVal('s', 'w', horActive);

                return new THREE.Vector3(x, 0, z);
            }

            animate() {
                const clock = new THREE.Clock();
                const frame = () => {
                    const dt = Math.min(clock.getDelta(), 0.05);

                    if(this.isLocked) {
                        const input = this.getTemporalVector();
                        
                        const needle = document.getElementById('needle');
                        const name = document.getElementById('dir-name');
                        if(input.length() > 0.01) {
                            needle.style.display = 'block';
                            const r = Math.atan2(input.x, -input.z);
                            needle.style.transform = `rotate(${r * (180/Math.PI)}deg)`;
                            const segs = ["N", "NNE", "NE", "ENE", "E", "ESE", "SE", "SSE", "S", "SSW", "SW", "WSW", "W", "WNW", "NW", "NNW"];
                            name.textContent = segs[Math.round(((r * 180/Math.PI) + 360) % 360 / 22.5) % 16];
                        } else {
                            needle.style.display = 'none';
                            name.textContent = "IDLE";
                        }

                        this.cameraRig.rotation.y = this.camYaw;
                        this.cameraPitch.rotation.x = this.camPitch;

                        if (input.length() > 0.01) {
                            const forward = new THREE.Vector3(0,0,-1).applyAxisAngle(new THREE.Vector3(0,1,0), this.camYaw);
                            const right = new THREE.Vector3(1,0,0).applyAxisAngle(new THREE.Vector3(0,1,0), this.camYaw);
                            
                            const moveVec = new THREE.Vector3().addScaledVector(right, input.x).addScaledVector(forward, -input.z).normalize();
                            this.velocity.x = moveVec.x * this.moveSpeed;
                            this.velocity.z = moveVec.z * this.moveSpeed;
                            this.player.rotation.y = Math.atan2(moveVec.x, moveVec.z);
                        } else {
                            this.velocity.x = 0; this.velocity.z = 0;
                        }

                        this.velocity.y -= this.gravity * dt;

                        const rayOrigin = this.player.position.clone().add(new THREE.Vector3(0, 1.5, 0));
                        const ray = new THREE.Raycaster(rayOrigin, new THREE.Vector3(0, -1, 0), 0, 1.7);
                        const hits = ray.intersectObjects(this.colliders);
                        
                        if(hits.length > 0) {
                            this.isGrounded = true;
                            if(this.velocity.y < 0) {
                                this.velocity.y = 0;
                                this.player.position.y = hits[0].point.y;
                            }
                        } else {
                            this.isGrounded = false;
                        }

                        if(this.isGrounded && this.keys.space) {
                            this.velocity.y = this.jumpForce;
                            this.isGrounded = false;
                        }

                        this.player.position.add(this.velocity.clone().multiplyScalar(dt));
                        this.cameraRig.position.copy(this.player.position);

                        if(this.player.position.y < -20) {
                            this.player.position.set(0, 0, 0);
                            this.velocity.set(0, 0, 0);
                        }
                    }

                    this.renderer.render(this.scene, this.camera);
                    requestAnimationFrame(frame);
                };
                frame();
            }
        }
        new StableDemo();
    </script>
</body>
</html>